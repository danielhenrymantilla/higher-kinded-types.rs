// ANCHOR: all
# #![feature(unboxed_closures)]
# mod lib {
#     pub trait ForLt { type Of<'__>; }
#     macro_rules! __ {( $T:ty ) => ( fn(&()) -> $T )} pub(crate) use __ as ForLt;
#     impl<F : for<'r> FnOnce<(&'r (), )>> ForLt for F {
#         type Of<'r> = <F as FnOnce<(&'r (), )>>::Output;
#     }
#
#     pub
#     struct Animaterium<'soul, Body : ForLt> {
#         _soul: ::core::marker::PhantomData<&'soul mut &'soul ()>,
#         carcass: Body::Of<'static>,
#     }
#
#     pub
#     fn soul_split<'soul, Body : ForLt>(value: Body::Of<'soul>)
#       -> Animaterium<'soul, Body>
#     {
#         Animaterium {
#             _soul: <_>::default(),
#             carcass: unsafe {
#                 ::core::mem::transmute::<Body::Of<'soul>, Body::Of<'_>>(value)
#             },
#         }
#     }
# }
# use lib::*;
#
// ANCHOR: exploit
struct PrintOnDrop<'str>(&'str str);

impl Drop for PrintOnDrop<'_> {
    fn drop(&mut self) {
        println!("{}", self.0);
    }
}

fn exploit()
{
    let _unrelated;

    let s = String::from("...");
    let drop_glue = PrintOnDrop(&s);
    let drop_glue = soul_split::<ForLt!(PrintOnDrop<'_>)>(drop_glue);
    drop(s);
    // Ideä to showcase the UB: let's reällocate a new "unrelated"
    // `String` right where `*s` used to be in.
    _unrelated = String::from("UB!");
} // <- `drop_glue` is dropped, derefing the dangling `&s`,
  //    which on my machine happens to point to `_unrelated`.
// ANCHOR_END: exploit
#
# fn main()
# {
#     exploit()
# }
// ANCHOR_END: all
