// ANCHOR: all
use ::core::{
    cell::Cell as Mutable,
    marker::PhantomData,
    ops::Not as _,
};

// ANCHOR: scoped-api
pub
struct PerThreadSingleton<'scope> {
    _opt_out_of_send: PhantomData<*mut ()>,
    _non_contravariant: PhantomData<&'scope ()>,
}

/// Scoped API!
impl PerThreadSingleton<'_> {                          // non-`'static`!
    pub                                                //        ðŸ‘‡
    fn scoped(yield_: impl for<'scope> FnOnce(PerThreadSingleton<'scope>)) {
        thread_local! {
            static EXISTS: Mutable<bool> = const { Mutable::new(false) };
        }
        EXISTS.with(|already_exists| {
            if already_exists.get().not() {
                already_exists.set(true);
                yield_(PerThreadSingleton {
                    _opt_out_of_send: <_>::default(),
                    _non_contravariant: <_>::default(),
                });
                already_exists.set(false); // ðŸ‘ˆ allowing us to soundly add this!
            }
        })
    }
}
// ANCHOR_END: scoped-api

// ANCHOR: two-instances
pub
fn two_instances(
    _a: PerThreadSingleton<'_>,
    _b: PerThreadSingleton<'_>,
) -> !
{
    // This is so impossible, that if a code path were to somehow hit this, then
    // it would be equivalent to having an instance of an uninhabited `enum`.
    // This can simply not be, and we decide to help the optimizer a bit by
    // telling it so:
    unsafe {
        // UB if reached!
        ::core::hint::unreachable_unchecked()
    }
}
// ANCHOR_END: two-instances

// ANCHOR: impl-send
/// # Safety
///   - The type is uninhabited (no way to construct such instances with
///     the only available `fn with_new()` constructor, thanks to
///     non-contravariance over its lifetime parameter (`'scope` cannot _grow_
///     up to `'static`)).
///   - You cannot send to another thread that which does not exist #RollSafeâ„¢
///   - _A fortiori_, you cannot cause cross-thread unsoundness with it!
unsafe
impl Send for PerThreadSingleton<'static> {}
// ANCHOR_END: impl-send

// ANCHOR: exploit
/// type PerThreadSingleton_::Of<'x> = PerThreadSingleton<'x>;
type PerThreadSingleton_ = ForLt!(PerThreadSingleton<'_>);

fn exploit() {
    PerThreadSingleton::scoped(|a| {
        // The current `a` is not `Send` since `'scope : 'static` does not hold.

        let a = soul_split::<PerThreadSingleton_>(a); // ðŸ‘ˆ source of the problem
        // now, this `a: Split<'a, PerThreadSingleton_>` is `Send`, since
        // its `carcass` field is a `PerThreadSingleton_::Of<'static>`, i.e.,
        // a `PerThreadSingleton<'static>`, which is `Send`.

        ::std::thread::scope(|s| _ = s.spawn(|| {
            // thus, this move to another thread is allowed!
            let a = a;

            // and now we can unsplit / re-unite the `'soul` and the `Body`:
            let a: PerThreadSingleton<'_> = Split::into_inner(a);

            // Now, let's introduce a new scope in this thread, which is OK,
            // since `EXISTS = true` is currently guarding the main thread only.
            PerThreadSingleton::scoped(|b| {

                // and now we have two `non-'static` instances in the same thread!
                let UB: ! = two_instances(a, b);
            })
        }));
    });
}
// ANCHOR_END: exploit
// ANCHOR_END: all

fn main()
{
    exploit();
}
