// ANCHOR: all
#![feature(never_type, unboxed_closures)]
use ::core::{
    cell::Cell as Mutable,
    marker::PhantomData,
    ops::Not as _,
};

// ANCHOR: scoped-api
pub
struct PerThreadSingleton<'scope> {
    _opt_out_of_send: PhantomData<*mut ()>,
    _non_contravariant: PhantomData<&'scope ()>,
}

/// Scoped API!
impl PerThreadSingleton<'_> {                          // non-`'static`!
    pub                                                //        ðŸ‘‡
    fn scoped(yield_: impl for<'scope> FnOnce(PerThreadSingleton<'scope>)) {
        thread_local! {
            static EXISTS: Mutable<bool> = const { Mutable::new(false) };
        }
        EXISTS.with(|already_exists| {
            if already_exists.get().not() {
                already_exists.set(true);
                yield_(PerThreadSingleton {
                    _opt_out_of_send: <_>::default(),
                    _non_contravariant: <_>::default(),
                });
                already_exists.set(false); // ðŸ‘ˆ allowing us to soundly add this!
            }
        })
    }
}
// ANCHOR_END: scoped-api

// ANCHOR: two-instances
pub
fn two_instances(
    _a: PerThreadSingleton<'_>,
    _b: PerThreadSingleton<'_>,
) -> !
{
    // This is so impossible, that if a code path were to somehow hit this, then
    // it would be equivalent to having an instance of an uninhabited `enum`.
    // This can simply not be, and we decide to help the optimizer a bit by
    // telling it so:
    unsafe {
        // UB if reached!
        ::core::hint::unreachable_unchecked()
    }
}
// ANCHOR_END: two-instances

// ANCHOR: impl-send
/// # Safety
///   - The type is uninhabited (no way to construct such instances with
///     the only available `fn with_new()` constructor, thanks to
///     non-contravariance over its lifetime parameter (`'scope` cannot _grow_
///     up to `'static`)).
///   - You cannot send to another thread that which does not exist #RollSafeâ„¢
///   - _A fortiori_, you cannot cause cross-thread unsoundness with it!
unsafe
impl Send for PerThreadSingleton<'static> {}
// ANCHOR_END: impl-send

// ANCHOR: exploit
/// type ForPerThreadSingleton::Of<'x> = PerThreadSingleton<'x>;
type ForPerThreadSingleton = ForLt!(PerThreadSingleton<'_>);

fn exploit() {
    PerThreadSingleton::scoped(|a| {
        // The current `a` is not `Send` since `'scope : 'static` does not hold.

        let a = soul_split::<ForPerThreadSingleton>(a); // ðŸ‘ˆ source of the problem
        // now, this `a: Animaterium<'a, ForPerThreadSingleton>` is `Send`, since
        // its `carcass` field is a `ForPerThreadSingleton::Of<'static>`, i.e.,
        // a `PerThreadSingleton<'static>`, which is `Send`.

        ::std::thread::scope(|s| _ = s.spawn(|| {
            // thus, this move to another thread is allowed!
            let a = a;

            // and now we can unsplit / re-unite the `'soul` and the `Body`:
            let a: PerThreadSingleton<'_> = Animaterium::into_inner(a);

            // Now, let's introduce a new scope in this thread, which is OK,
            // since `EXISTS = true` is currently guarding the main thread only.
            PerThreadSingleton::scoped(|b| {
                // and now we have two non-`'static` instances in the same thread!
                let UB: ! = two_instances(a, b);
            })
        }));
    });
}
// ANCHOR_END: exploit

fn main()
{}

mod lib {
    pub trait ForLt { type Of<'__>; }
    macro_rules! __ {( $T:ty ) => ( fn(&()) -> $T )} pub(crate) use __ as ForLt;
    impl<F : for<'r> FnOnce<(&'r (), )>> ForLt for F {
        type Of<'r> = <F as FnOnce<(&'r (), )>>::Output;
    }

    pub
    struct Animaterium<'soul, Body : ForLt> {
        _soul: ::core::marker::PhantomData<&'soul mut &'soul ()>,
        carcass: Body::Of<'static>,
    }

    pub
    fn soul_split<'soul, Body : ForLt>(value: Body::Of<'soul>)
      -> Animaterium<'soul, Body>
    {
        Animaterium {
            _soul: <_>::default(),
            carcass: unsafe {
                ::core::mem::transmute::<Body::Of<'soul>, Body::Of<'_>>(value)
            },
        }
    }

    impl<'soul, Body : ForLt> Animaterium<'soul, Body> {
        pub
        fn into_inner(self) -> Body::Of<'soul> {
            unsafe { ::core::mem::transmute(self.carcass) }
        }
    }
}
use lib::*;
// ANCHOR_END: all
